def kthPermutation(n, k):
    # 2. Optimized Solution
    # Approach: Caclulate permutation to be fetched from every subset generated by processing one index at a time
    # Time Complexity: O(N*N) - For processing every input O(N), for deleting element at idx i, O(N)
    # Space Complexity: O(N) - List for building kth permutation
    
    def factorial(n):
        if n == 1:
            return n
        return n*factorial(n-1)
    
    s = []  # Input Array Generation
    for i in range(1,n+1):
        s.append(i)
        
    kth_permutation = []
    k = k-1 # O based indexing of permutations
    
    # While elements exists in s, will keep deleting one element after every iteration
    while(s):
        # Calculate set size based on elements left in s
        set_size = int(factorial(n)/n)
        # Calculate idx to pick for current iteration and append
        idx = int(k / set_size)
        kth_permutation.append(s[idx])
        s.pop(idx) # Remove element from s after processing
        n -= 1
        k = k % set_size  # Update the permutation to be fetched from the new set s generated above
    
    # List to String Conversion as required by question
    kth_permutation_str = "".join(str(e) for e in kth_permutation)  
    return kth_permutation_str

# -----------------------

   # 1. Naive Solution
    # Approach: Generate all Permutations, sort and return kth permutation
    # Time Complexity: O(N!)*O(N) 
    # Space Complexity: O(N) for main_list
#     freq_map = [0] * n
#     main_list = []
#     sub_list = []
#     s = []
#     for i in range(1,n+1):
#         s.append(i)
        
#     def backtrack():
#         if len(sub_list) == len(s):
#             # Base Case
#             main_list.append("".join(str(e) for e in sub_list)) # List to String
#             return
        
#         # Loop over possibilites - all elements available
#         for i in range(n):
#             if not freq_map[i]:
#                 # If not used already, append, mark as visited and backtrack
#                 sub_list.append(s[i])
#                 freq_map[i] = 1
#                 backtrack()
#                 sub_list.pop()
#                 freq_map[i] = 0 # Unassign and unmark
            
#     backtrack()
#     main_list.sort() # To get kth permutation
#     return main_list[k-1]
